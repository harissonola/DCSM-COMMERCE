{% extends 'base.html.twig' %}

{% block title %}
	Dashboard |
	{{ prod.name }}
{% endblock %}

{% block stylesheets %}
	{{ parent() }}
	<style>
		#tradingChart {
			background: #1a1a1a;
			border-radius: 8px;
			padding: 15px;
			transition: opacity 0.3s ease;
			cursor: crosshair;
		}
		.chartjs-tooltip {
			background: #2A2E35 !important;
			border-radius: 4px;
			pointer-events: none;
			box-shadow: 0 2px 8px rgba(0,0,0,0.2);
			transition: all 0.1s ease;
		}
		.loading-overlay {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(0, 0, 0, 0.5);
			display: none;
			align-items: center;
			justify-content: center;
			color: #fff;
			font-size: 1.2em;
		}
	</style>
{% endblock %}

{% block body %}
	<!-- Chart.js CDN -->
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

	<div class="container-fluid py-5 mt-3">
		<div style="position: relative; height: 60vh;">
			<div class="loading-overlay" id="chartLoading">
				<div class="spinner-border text-primary" role="status">
					<span class="visually-hidden">Chargement...</span>
				</div>
			</div>
			<canvas id="tradingChart"></canvas>
		</div>
	</div>

	{# <div class="container-fluid mt-4">
		{% if app.user and app.user.isMiningBotActive %}
			<div class="alert alert-success">
				Votre bot de minage est activé. Le minage se fait automatiquement.
			</div>
		{% else %}
			<div class="alert alert-danger">
				Vous n'avez pas le bot de minage. Vous pouvez miner manuellement, mais vous serez responsable de vos gains/pertes.
			</div>
		{% endif %}
	</div> #}
{% endblock %}

{% block customScript %}
<script>
document.addEventListener('DOMContentLoaded', function () {
    const ctx = document.getElementById('tradingChart');
    const loadingOverlay = document.getElementById('chartLoading');
    if (!ctx) return;

    let chartInstance = null;
    const hasMiningBot = {{ app.user and app.user.isMiningBotActive ? 'true' : 'false' }};
    const productSlug = '{{ prod.slug }}';
    let updateInterval;

    async function updateChart() {
        try {
            loadingOverlay.style.display = 'flex';
            const response = await fetch(`/products/${productSlug}/dashboard/data`);
            if (!response.ok) throw new Error('Erreur réseau');
            
            const newData = await response.json();
            
            if (chartInstance) {
                chartInstance.data.datasets[0].data = processData(newData.price);
                chartInstance.data.datasets[1].data = processData(newData.market_cap);
                chartInstance.update('none');
            }
        } catch (error) {
            console.error('Erreur actualisation:', error);
        } finally {
            loadingOverlay.style.display = 'none';
        }
    }

    function initChart(initialData) {
        if (chartInstance) chartInstance.destroy();

        chartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [
                    {
                        label: 'Prix (USD)',
                        data: processData(initialData.price),
                        borderColor: '#2962FF',
                        borderWidth: 1.5,
                        yAxisID: 'y',
                        tension: 0.4
                    },
                    {
                        label: 'Capitalisation',
                        data: processData(initialData.market_cap),
                        borderColor: '#FF6D00',
                        borderWidth: 1.5,
                        yAxisID: 'y1',
                        tension: 0.4
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: { color: '#fff' }
                    },
                    tooltip: {
                        mode: 'nearest',
                        intersect: false,
                        axis: 'x',
                        backgroundColor: '#2A2E35',
                        titleColor: '#fff',
                        bodyColor: '#fff',
                        callbacks: {
                            label: (context) => `${context.dataset.label}: $${context.parsed.y.toFixed(2)}`
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'hour',
                            stepSize: 2,
                            displayFormats: { hour: 'HH:mm:ss' }
                        },
                        grid: { color: '#2A2E35' },
                        ticks: { color: '#666' }
                    },
                    y: {
                        position: 'left',
                        grid: { color: '#2A2E35' },
                        ticks: { color: '#666' },
                        title: { 
                            display: true, 
                            text: 'Prix (USD)', 
                            color: '#666' 
                        }
                    },
                    y1: {
                        position: 'right',
                        grid: { drawOnChartArea: false },
                        ticks: { color: '#666' },
                        title: { 
                            display: true, 
                            text: 'Capitalisation (USD)', 
                            color: '#666' 
                        }
                    }
                }
            }
        });

        const interval = hasMiningBot ? 120000 : 1800000;
        clearInterval(updateInterval);
        updateInterval = setInterval(updateChart, interval);
    }

    function processData(rawData) {
        return rawData.map(item => {
            try {
                return { 
                    x: new Date(item.x), 
                    y: parseFloat(item.y) 
                };
            } catch (e) {
                console.warn("Donnée invalide:", item);
                return null;
            }
        }).filter(item => item !== null);
    }

    try {
        const initialData = {{ chartData|json_encode|raw }};
        initChart(initialData);
    } catch (e) {
        console.error("Erreur initialisation:", e);
    }

    document.addEventListener('turbo:before-cache', () => {
        if (chartInstance) {
            chartInstance.destroy();
            chartInstance = null;
        }
        clearInterval(updateInterval);
    });
});
</script>
{% endblock %}